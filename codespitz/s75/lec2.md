# 코드스피츠 디자인 패턴 2강 내용정리
---
* 역할 모델
  * 디자인 패턴 자체가 중요한 것은 아니다
  * 그 뒤에 있는 역할 모델에 대한 이해가 필요하다
  * 역할 모델과 관련해 어떤 것이 좋은 패턴인지 이유를 알면 반복해서 사용할 수 있다

* 디자인 패턴의 분류
  * 디자인 패턴에서 가장 유명한 책은 GoF의 디자인패턴이다
  * GoF의 책은 디자인 패턴을 크게 생성패턴, 구조패턴, 행동패턴으로 나눈다
  * 생성패턴은 객체를 생성할 때 사용하면 좋은 패턴들이다
  * 구조패턴은 객체끼리 관계를 맺을 때 좋은 패턴들이다
  * 행동패턴은 알고리즘(행동)을 객체 간의 협력모델로 풀 때 좋은 패턴이다

* 객체지향의 중요성
  * 그런데 디자인 패턴은 객체지향에 친숙한 사람만이 이해 가능하다
  * 객체지향에 대한 이해 없이는 단순 암기처럼 보일뿐 왜 사용하는지 이유를 파악할 수 없다

* 변화에 대응하기
  * 우리가 해결해야 하는 문제들은 알고리즘으로 되어있다
  * 그리고 알고리즘은 대부분 확정적이지 않고 상황마다 계속 변화한다(게시판의 pagenation 등)
  * 문제는 변화의 원인이 무엇이든(비즈니스, 라이브러리, 호스트) 대부분 개발자가 통제할 수 없다
  * ### *변하지 않는 것은 모든 프로그램은 변한다는 사실 뿐이다*
  * 따라서 변화에 잘 적응할 수 있는 프로그램을 만드는 것이 프로그래밍의 핵심 문제가 된다
 
* 격리
  * 변화에 잘 적응하기 위해서는 격리를 잘해야 한다
  * 격리에 성공하면 유지보수하기 좋은 애플리케이션을 만들 수 있다
  * 대부분의 프로그래머들은 제어문 기반의 알고리즘으로 애플리케이션을 작성한다
  * 이런 방식의 문제는 수정시 전체가 컴파일되고 따라서 전체를 다시 테스트해야 하는 문제가 생긴다
  * 여기에 대한 가장 기초적 대안은 제어문 내부의 로직을 함수로 만들어 격리시키는 것이다
  * 그러나 함수를 이용한 격리는 경우의 수의 변경, 함수 간 공통부문 관리에 충분히 대응할 수 없다
  
* 객체지향의 격리
  * 객체지향에서는 알고리즘 분화에 대응하기 위해 크게 두 가지 방법을 사용한다
  * 상속 위임은 내부계약관계를 맺어 추상층에서 공통 요소를 해결하고 상태를 공유한다
  * 소유 위임은 외부계약관계로 각각이 독립적인 문제를 해결하고 메시지를 주고받아 문제를 해결한다

* 상속 위임
  * 상속 위임에서 많이 쓰이는 패턴 중 하나는 Template method pattern이다
  * 추상층의 공통부분(특정 함수) 안에 자식이 처리하는 위임부분이 있다
  * 위임하는 hook을 호출하는 method를 template method라고 부른다
  * 그리고 위임부분이 되는 자식의 method나 override된 추상층의 method를 hook이라 부른다

* 소유 위임
  * 소유 위임에서는 독립적인 문제를 해결할 객체(함수나 다른 클래스)를 받아들인다
  * 문제 해결을 위해 받아들이는 객체를 전략 객체라고 부른다
  * 전략 객체를 함수로 처리하는 경우 부가적인 형(클래스)을 작성하고 관리하는 부담이 줄어든다
  * 물론 여기에 장점만 있는 것은 아니다. 함수의 안정성을 직접 담보해야하기 때문이다
  * 형을 사용할지 함수를 사용할지 여부는 위임해야하는 문제가 얼만큼의 신용도가 필요한 문제냐에 따라서 선택가능하다

* 알고리즘과 용량  
  * if문을 전부 없앨 수는 없다. 다만 제어문을 늘리지 않기 위해서 값을 사용할 수 있다
  * 이 때 map같은 객체를 사용해서 라우터로 사용할 수 있다
  * map에 값에 따른 처리기를 넣어주면 배열처럼 증식시킬 수 있다
  * 이처럼 알고리즘은 용량으로 대체할 수 있고 반대로 용량은 알고리즘으로 대체할 수 있다
  * 정리해보면 정의 시점에서 분기를 제거하는 방법은 
    1. 분기 수만큼 객체를 만들고 
    2. 실행시점에 경우의 수를 공급하는 것이다